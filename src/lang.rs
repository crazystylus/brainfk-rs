use crate::compiler;
use crate::{Backend, Target};
use std::collections::HashSet;
use std::fs;
use std::io;

use wasm_encoder::EntityType;
use wasm_encoder::ExportSection;
use wasm_encoder::{
    CodeSection, Function, FunctionSection, ImportSection, Instruction, MemorySection, MemoryType,
    Module, TypeSection, ValType,
};
use wasmer::Module as WasmerModule;
use wasmer::{Cranelift, Instance, Singlepass, Store, Universal, LLVM};
use wasmer_wasi::{Stdin, Stdout, WasiState};

pub(crate) struct Language {
    /// This contains the characterset from brainfk language
    pub char_set: HashSet<char>,
    /// Character by language symbols
    pub code: Vec<char>,
    /// Generated bytecode
    pub wasm_bytes: Vec<u8>,
}

impl Language {
    pub fn new() -> Self {
        Self {
            char_set: HashSet::from(['<', '>', '+', '-', '.', ',', '[', ']']),
            code: Vec::new(),
            wasm_bytes: Vec::new(),
        }
    }

    /// Open and parse the code
    pub fn parse(&mut self, input_file: &str) -> Result<(), io::Error> {
        let path = std::path::Path::new(input_file);
        let content = fs::read_to_string(path)?;
        self.code = content
            .chars()
            .filter(|x| self.char_set.contains(x))
            .collect();
        Ok(())
    }

    /// Generate WASM bytecode
    pub fn generate_wasm(&mut self, target: &Target) -> Result<(), io::Error> {
        // Create a new module
        let mut module = Module::new();
        // Type section for void function
        let mut types = TypeSection::new();
        // Types for main function
        types.function([], []);
        match target {
            Target::Browser => {
                // Types for JS functions
                todo!();
            }
            Target::Wasi => {
                // Types for fd_read and fd_write
                types.function(
                    vec![ValType::I32, ValType::I32, ValType::I32, ValType::I32],
                    vec![ValType::I32],
                );
                types.function(
                    vec![ValType::I32, ValType::I32, ValType::I32, ValType::I32],
                    vec![ValType::I32],
                );
            }
        }
        module.section(&types);
        let mut imports = ImportSection::new();
        match target {
            Target::Browser => {
                // Import JS functions
                todo!();
            }
            Target::Wasi => {
                // Import WASI functions
                imports.import("wasi_unstable", "fd_read", EntityType::Function(1));
                imports.import("wasi_unstable", "fd_write", EntityType::Function(2));
            }
        }
        module.section(&imports);

        let mut functions = FunctionSection::new();
        let type_index = 0;
        functions.function(type_index);
        module.section(&functions);

        let mut memories = MemorySection::new();
        // Memory for Input Stream
        memories.memory(MemoryType {
            minimum: 3, // 30,000 elements roughly 2 pages
            maximum: None,
            memory64: false,
            shared: false,
        });

        module.section(&memories);

        let mut exports = ExportSection::new();
        exports.export("memory", wasm_encoder::ExportKind::Memory, 0);
        exports.export("_start", wasm_encoder::ExportKind::Func, 2);
        module.section(&exports);

        // let start = match target {
        //     Target::Browser => StartSection { function_index: 0 },
        //     Target::Wasi => StartSection { function_index: 2 },
        // };
        // module.section(&start);

        let mut codes = CodeSection::new();
        // Local Declaration
        // Local 0 : I32 TAPE Pointer
        // ...
        let locals = vec![(3, ValType::I32)];
        let mut f = Function::new(locals);

        // <-- Linear Memory Model -->
        // ---------------------------
        // | IOV  and Tmp |  TAPE    |
        // 0-----------1024------4096|
        // TODO: Check if memory pointer invalid
        // TODO: Tape expansion
        f.instruction(&Instruction::I32Const(1024));
        f.instruction(&Instruction::LocalSet(0));

        // Symbol matching
        let mut fcount: u32 = 2;
        for symb in &self.code {
            match symb {
                '<' => compiler::less_than(&mut f),
                '>' => compiler::greater_than(&mut f),
                '+' => compiler::plus(&mut f),
                '-' => compiler::minus(&mut f),
                ',' => compiler::comma(&mut f, target),
                '.' => compiler::dot(&mut f, target),
                '[' => {
                    fcount += 1;
                    compiler::sq_start(&mut f, fcount);
                }
                ']' => compiler::sq_end(&mut f),
                _ => {
                    f.instruction(&Instruction::Nop);
                }
            }
        }
        // Cleanup
        f.instruction(&Instruction::End);

        codes.function(&f);
        module.section(&codes);

        self.wasm_bytes = module.finish();
        Ok(())
    }

    /// Validate generated WASM bytecode
    pub fn validate(&self) -> Result<wasmparser::types::Types, wasmparser::BinaryReaderError> {
        wasmparser::validate(&self.wasm_bytes)
    }

    /// Write generated WASM bytecode to file
    pub fn write_wasm(&self, output_file: &str) -> Result<(), io::Error> {
        fs::write(output_file, &self.wasm_bytes)
    }

    /// Compile wasm to wasmu
    pub fn compile_wasmu(&self, output_file: &str, backend: &Backend) -> Result<(), io::Error> {
        let engine = match backend {
            &Backend::LLVM => Universal::new(LLVM::default()).engine(),
            &Backend::Cranelift => Universal::new(Cranelift::default()).engine(),
            &Backend::Singlepass => Universal::new(Singlepass::default()).engine(),
        };
        let store = Store::new(&engine);
        let module = WasmerModule::new(&store, &self.wasm_bytes).unwrap();
        module.serialize_to_file(output_file).unwrap();
        Ok(())
    }

    /// TODO: Compile to a binary using wasmer
    pub fn compile_binary(&self, _output_file: &str, _backend: &Backend) -> Result<(), io::Error> {
        todo!();
    }

    /// Run bf-code
    pub fn run(&self, backend: &Backend) {
        let engine = match backend {
            &Backend::LLVM => Universal::new(LLVM::default()).engine(),
            &Backend::Cranelift => Universal::new(Cranelift::default()).engine(),
            &Backend::Singlepass => Universal::new(Singlepass::default()).engine(),
        };
        let store = Store::new(&engine);
        let module = WasmerModule::new(&store, &self.wasm_bytes).unwrap();
        let mut wasi_env = WasiState::new("brainfk")
            .stdin(Box::new(Stdin))
            .stdout(Box::new(Stdout))
            .finalize()
            .unwrap();
        let import_object = wasi_env.import_object(&module).unwrap();
        let instance = Instance::new(&module, &import_object).unwrap();
        let start = instance.exports.get_function("_start").unwrap();
        start.call(&[]).unwrap();
    }
}
